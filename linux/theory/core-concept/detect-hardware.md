# Communication with Hardware in Linux System

The **` device driver `** is the abstraction layer between software concepts and hardware circuitry as such, it needs to talk with both of them. In this chapter we will discuss, how a driver can access **` I/O ports `** and **` I/O memory `**. 

Whenever we inserted the devices to the running machine, dynamically a file gets created for that particular device and generally it shows into the **` /dev/ `** directory with some meaningfull name.

Suppose we require to connect **` USB Device `** to the running machine or system. Then **` kernel `** quitely does their job internally and executes the various services to acheve the goals. 
  - Post inserting the **` USB Device `** to the running system or machine the corresponding **device driver** which resides in the **` kernel space `** detects the state change and generates the events which is **` uevents `**.
  - The **` udev `** daemon, **systemd-udevd.service**, receives device **` uevents `** directly from the kernel whenever a device is added or removed from the system or it changes its state.
  - When **` udev `** receives a device event, it matches its configured set of rules against various device attributes to identify the device.
  - **` udev `** supplies the system software with device events, manages permissions of device nodes and may create additional symlinks in the ${\color{purple}/dev/}$ directory.
  - The **` udev `** rules are read from the files located in the directories ${\color{green}/usr/lib/udev/rules.d}$ and ${\color{green}/usr/local/lib/udev/rules.d}$, the volatile runtime directory ${\color{green}/run/udev/rules.d}$ and the local administration directory ${\color{green}/etc/udev/rules.d}$.
  - Files in ${\color{green}/etc/}$ have the highest priority.
  - Once the process is completed the newly inserted or attached device will shwon in the **` /dev/ `** directory with dynamic name created by **` udev `** Dynamic Device Management. 
  - **` udev `** is basically a piece of code or a **User Space** program, which receives signal or notification from **` kernel `**.

  <img src="../../images/core-concept/connect-device/attach-device.png" height="550" width="800" >
  
  Now we can see the attached device under ${\color{green}/dev/}$ directory and can verify by executing below commands:
  ```
  # lsblk
  # df -hT
  ```
  ![device connect](../../images/core-concept/connect-device/connect-usb.png)
  
### Operators in udev rules file
| **Operators** | **Description**                                                 |
|---------------|-----------------------------------------------------------------|
| **` == `**    | Compare for equality.                                           |
| **` != `**    | Compare for inequality.                                         |
| **` = `**     | Assign a value to a key.                                        |
| **` += `**    | Add the value to a key that holds a list of entries.            |
| **` -= `**    | Remove the value from a key that holds a list of entries.       |
| **` := `**    | Assign a value to a key finally; disallow any later changes.    |

### **Detect Device Connectivity Status using *` dmesg `* command**
**` dmesg `** can be used to display the message of **` Kernel Ring Buffer `** generated by the **kernel**. The numerous messages generated by the **` kernel `** whenever the linux based system boots up and this is also contains logs which is produced by the hardware devices that the kernel detects and indicate whether it is able to configure them. To identfy or display **` kernel ring buffer `** messages/logs execute the below command.
```
# dmesg
```
**OR** to read in human readable form and with standard date and time.
```
# dmesg -HTx
```
![kernel ring buffer](../../images/core-concept/connect-device/usb-dmesg.png)

A level is assigned to each message logged to the *` kernel ring buffer `*. The level represents the significance of the information in the communication. The levels are as follows:
| **levels**    | **Description**                                                                      |
|---------------|-----------------------------------------------------------------------|
| **` emerg `** | In this situation not able to use system.                             |
| **` alert `** | Something happened wrong and immediate action required.               |
| **` crit `**  | Critical condition occured like hardware or software related failure. |
| **` err `**   | An error occured related to hardware                                  |
| **` warn `**  | Nothing serious but might indicate some issue.                        |
| **` notice `**| Often report security events.                                         |
| **` info `**  | Startup informational message.                                        |
| **` debug `** | Debug message.                                                        |


The **` dmesg `** command extract the messages that match a particular **level** by using the **` -l `** option and passing the name of the level as a command-line argument.<br>
${\color{orange}Syntax:}$
```
# dmesg -l level_name
```
Replace the level_name with desired level.<br>
${\color{orange}Example:}$<br>
```
# dmesg -l warn
```
To see more than one level based message execute the below command:
```
# dmesg -l info,notice
```
The **` dmesg `** messages are grouped into categories called **facilities**. The list of facilities are as follow:

| **Facilities**  | **Description**                  |
|-----------------|----------------------------------|
| **` kern `**    | Kernel message.                  |
| **` user `**    | User-level message.              |
| **` mail `**    | Logs related to mail system.     |
| **` daemon `**  | Message related to System daemon |
| **` auth `**    | Security and authorization message. |
| **` syslog `**  | Internal syslogd message.           |
| **` lpr `**     | Line printer sub-system.            |
| **` news `**    | Network news sub-system.            |

The **` dmesg `** can filter its output to only show messages in a specific facility. To do so, we must use the **` -f `** option:<br>
${\color{orange}Example:}$<br>
```
# dmesg -f kern
```
We can combine the both **` facility `** and **` level `** togather using **` -x `** option:
```
# dmesg -x
```
![level & facility](../../images/core-concept/connect-device/level-facility.png)



